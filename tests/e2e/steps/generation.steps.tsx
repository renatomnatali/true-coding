/**
 * generation.steps.tsx â€” Step definitions for generation.feature
 *
 * Scenarios reference:
 * docs/specifications/generation.feature
 */

import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { GenerationProgress } from '@/components/project/GenerationProgress'
import { POST } from '@/app/api/generate/route'

// ---------------------------------------------------------------------------
// Mocks for API route dependencies
// ---------------------------------------------------------------------------
vi.mock('@clerk/nextjs/server', () => ({
  auth: vi.fn(),
}))

vi.mock('@/lib/db/prisma', () => ({
  prisma: {
    project: {
      findUnique: vi.fn(),
      update: vi.fn(),
    },
  },
}))

vi.mock('@/lib/codegen/generator', () => ({
  generateProject: vi.fn(),
}))

vi.mock('@/lib/github/client', () => ({
  createGitHubClient: vi.fn(),
  createRepository: vi.fn(),
  createCommit: vi.fn(),
  getRepository: vi.fn(),
}))

vi.mock('@/lib/crypto', () => ({
  decrypt: vi.fn(),
}))

import { auth } from '@clerk/nextjs/server'
import { prisma } from '@/lib/db/prisma'

const mockAuth = vi.mocked(auth)
const mockPrisma = vi.mocked(prisma)
const mockProjectFindUnique = prisma.project.findUnique as unknown as ReturnType<typeof vi.fn>
const mockProjectUpdate = prisma.project.update as unknown as ReturnType<typeof vi.fn>

function createRequest(body: unknown) {
  return new Request('http://localhost/api/generate', {
    method: 'POST',
    body: JSON.stringify(body),
  })
}

async function consumeResponseStream(response: Response): Promise<string> {
  const reader = response.body?.getReader()
  if (!reader) return ''

  const decoder = new TextDecoder()
  let output = ''

  while (true) {
    const { done, value } = await reader.read()
    if (done) break
    output += decoder.decode(value)
  }

  return output
}

// ---------------------------------------------------------------------------
// API scenarios
// ---------------------------------------------------------------------------
describe('Generation Phase (BDD) -> API /api/generate', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('Cenario: Reutilizar repositorio ja conectado', async () => {
    mockAuth.mockResolvedValue({
      userId: 'user_123',
    } as ReturnType<typeof auth> extends Promise<infer T> ? T : never)

    mockProjectFindUnique.mockResolvedValue({
      id: 'proj-1',
      name: 'Test Project',
      description: 'Test description',
      technicalPlan: {
        dataModel: { entities: [] },
        pages: [],
        components: [],
        apiEndpoints: [],
      },
      githubRepoUrl: 'https://github.com/user/existing-repo',
      githubRepoOwner: 'user',
      githubRepoName: 'existing-repo',
      user: {
        clerkId: 'user_123',
        githubAccessToken: 'encrypted_token',
      },
    } as unknown as Awaited<ReturnType<typeof prisma.project.findUnique>>)

    const { generateProject } = await import('@/lib/codegen/generator')
    const mockedGenerateProject = vi.mocked(generateProject)
    mockedGenerateProject.mockImplementation(async function* () {
      yield { type: 'stage' as const, stage: 'loading_templates' as const }
      yield { type: 'done' as const, files: [{ path: 'package.json', content: '{}' }] }
    })

    const { createGitHubClient, createRepository, createCommit, getRepository } = await import('@/lib/github/client')
    const mockedCreateGitHubClient = vi.mocked(createGitHubClient)
    const mockedCreateRepository = vi.mocked(createRepository)
    const mockedCreateCommit = vi.mocked(createCommit)
    const mockedGetRepository = vi.mocked(getRepository)

    mockedCreateGitHubClient.mockReturnValue({} as ReturnType<typeof createGitHubClient>)
    mockedGetRepository.mockResolvedValue({
      default_branch: 'main',
    } as Awaited<ReturnType<typeof getRepository>>)
    mockedCreateCommit.mockResolvedValue({ sha: 'commit_sha' } as Awaited<ReturnType<typeof createCommit>>)
    mockProjectUpdate.mockResolvedValue({} as Awaited<ReturnType<typeof prisma.project.update>>)

    const { decrypt } = await import('@/lib/crypto')
    vi.mocked(decrypt).mockReturnValue('decrypted_token')

    const response = await POST(createRequest({ projectId: 'proj-1' }))
    await consumeResponseStream(response)

    expect(response.status).toBe(200)
    expect(mockedCreateRepository).not.toHaveBeenCalled()
    expect(mockedCreateCommit).toHaveBeenCalledWith(
      expect.anything(),
      'user',
      'existing-repo',
      [{ path: 'package.json', content: '{}' }],
      'Initial commit - Generated by True Coding',
      'main'
    )
  })

  it('Cenario: Falha de commit marca projeto como FAILED', async () => {
    mockAuth.mockResolvedValue({
      userId: 'user_123',
    } as ReturnType<typeof auth> extends Promise<infer T> ? T : never)

    mockProjectFindUnique.mockResolvedValue({
      id: 'proj-1',
      name: 'Test Project',
      description: 'Test description',
      technicalPlan: {
        dataModel: { entities: [] },
        pages: [],
        components: [],
        apiEndpoints: [],
      },
      githubRepoUrl: 'https://github.com/user/existing-repo',
      githubRepoOwner: 'user',
      githubRepoName: 'existing-repo',
      user: {
        clerkId: 'user_123',
        githubAccessToken: 'encrypted_token',
      },
    } as unknown as Awaited<ReturnType<typeof prisma.project.findUnique>>)

    const { generateProject } = await import('@/lib/codegen/generator')
    const mockedGenerateProject = vi.mocked(generateProject)
    mockedGenerateProject.mockImplementation(async function* () {
      yield { type: 'stage' as const, stage: 'loading_templates' as const }
      yield { type: 'done' as const, files: [{ path: 'package.json', content: '{}' }] }
    })

    const { createGitHubClient, createCommit, getRepository } = await import('@/lib/github/client')
    const mockedCreateGitHubClient = vi.mocked(createGitHubClient)
    const mockedCreateCommit = vi.mocked(createCommit)
    const mockedGetRepository = vi.mocked(getRepository)

    mockedCreateGitHubClient.mockReturnValue({} as ReturnType<typeof createGitHubClient>)
    mockedGetRepository.mockResolvedValue({
      default_branch: 'main',
    } as Awaited<ReturnType<typeof getRepository>>)
    mockedCreateCommit.mockRejectedValue(new Error('COMMIT_FAILED'))
    mockProjectUpdate.mockResolvedValue({} as Awaited<ReturnType<typeof prisma.project.update>>)

    const { decrypt } = await import('@/lib/crypto')
    vi.mocked(decrypt).mockReturnValue('decrypted_token')

    const response = await POST(createRequest({ projectId: 'proj-1' }))
    const body = await consumeResponseStream(response)

    expect(response.status).toBe(200)
    expect(body).toContain('"type":"error"')
    expect(body).toContain('COMMIT_FAILED')
    expect(mockPrisma.project.update).toHaveBeenCalledWith({
      where: { id: 'proj-1' },
      data: { status: 'FAILED' },
    })
  })
})

// ---------------------------------------------------------------------------
// UI scenario
// ---------------------------------------------------------------------------
describe('Generation Phase (BDD) -> UI feedback and retry', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('Cenario: Em modo manual mostra estado pronto e botao iniciar', async () => {
    const fetchSpy = vi.fn()
    vi.stubGlobal('fetch', fetchSpy)

    render(<GenerationProgress projectId="proj-1" autoStart={false} />)

    expect(screen.getByText('Pronto para gerar')).toBeInTheDocument()
    expect(screen.getByRole('button', { name: 'Iniciar geracao' })).toBeInTheDocument()
    expect(fetchSpy).not.toHaveBeenCalled()
  })

  it('Cenario: Erro da API exibe mensagem e permite tentar novamente', async () => {
    const user = userEvent.setup()

    const fetchMock = vi
      .fn()
      .mockResolvedValue({
        ok: false,
        json: async () => ({ error: 'GITHUB_NOT_CONNECTED' }),
      })

    vi.stubGlobal('fetch', fetchMock)

    render(<GenerationProgress projectId="proj-1" autoStart={false} />)
    await user.click(screen.getByRole('button', { name: 'Iniciar geracao' }))

    await waitFor(() => {
      expect(
        screen.getByText('GitHub nao conectado para este projeto.')
      ).toBeInTheDocument()
    })

    expect(screen.getByRole('button', { name: 'Tentar novamente' })).toBeInTheDocument()
  })

  it('Cenario: Evento SSE de erro quebrado em chunks ainda mostra falha corretamente', async () => {
    const user = userEvent.setup()
    const encoder = new TextEncoder()

    const stream = new ReadableStream({
      start(controller) {
        controller.enqueue(
          encoder.encode(
            'data: {"type":"stage","stage":"generating_files"}\n\n'
          )
        )
        controller.enqueue(
          encoder.encode(
            'data: {"type":"file_generated","file":{"path":"package.json","content":"{}"}}\n\n'
          )
        )
        controller.enqueue(
          encoder.encode('data: {"type":"error","error":"COM')
        )
        controller.enqueue(
          encoder.encode('MIT_FAILED"}\n\n')
        )
        controller.close()
      },
    })

    const fetchMock = vi.fn().mockResolvedValue({
      ok: true,
      body: stream,
    })

    vi.stubGlobal('fetch', fetchMock)

    render(<GenerationProgress projectId="proj-1" autoStart={false} />)
    await user.click(screen.getByRole('button', { name: 'Iniciar geracao' }))

    await waitFor(() => {
      expect(screen.getByText('COMMIT_FAILED')).toBeInTheDocument()
    })

    expect(screen.getByRole('button', { name: 'Tentar novamente' })).toBeInTheDocument()
  })
})
