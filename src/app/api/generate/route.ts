import { auth } from '@clerk/nextjs/server'
import { prisma } from '@/lib/db/prisma'
import { generateProject, GenerationEvent } from '@/lib/codegen/generator'
import { TechnicalPlan } from '@/lib/ai/prompts/planning'
import {
  createGitHubClient,
  createRepository,
  createCommit,
} from '@/lib/github/client'
import { decrypt } from '@/lib/crypto'

export async function POST(request: Request) {
  try {
    const { userId } = await auth()
    if (!userId) {
      return new Response(JSON.stringify({ error: 'UNAUTHORIZED' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json' },
      })
    }

    const body = await request.json()
    const { projectId } = body

    if (!projectId) {
      return new Response(JSON.stringify({ error: 'PROJECT_ID_REQUIRED' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
      })
    }

    // Get project with technical plan
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      include: { user: true },
    })

    if (!project) {
      return new Response(JSON.stringify({ error: 'PROJECT_NOT_FOUND' }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' },
      })
    }

    if (project.user.clerkId !== userId) {
      return new Response(JSON.stringify({ error: 'FORBIDDEN' }), {
        status: 403,
        headers: { 'Content-Type': 'application/json' },
      })
    }

    if (!project.technicalPlan) {
      return new Response(
        JSON.stringify({ error: 'TECHNICAL_PLAN_REQUIRED' }),
        {
          status: 400,
          headers: { 'Content-Type': 'application/json' },
        }
      )
    }

    // Check GitHub connection
    if (!project.user.githubAccessToken) {
      return new Response(
        JSON.stringify({ error: 'GITHUB_NOT_CONNECTED' }),
        {
          status: 400,
          headers: { 'Content-Type': 'application/json' },
        }
      )
    }

    // Create a streaming response
    const encoder = new TextEncoder()
    const stream = new ReadableStream({
      async start(controller) {
        const sendEvent = (event: GenerationEvent) => {
          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify(event)}\n\n`)
          )
        }

        try {
          const technicalPlan = project.technicalPlan as unknown as TechnicalPlan
          const projectData = {
            id: project.id,
            name: project.name,
            description: project.description || '',
            technicalPlan,
            hasAuth: true,
            hasDatabase: technicalPlan.dataModel.entities.length > 0,
          }

          let allFiles: Array<{ path: string; content: string }> = []

          // Generate files
          for await (const event of generateProject(projectData)) {
            sendEvent(event)

            if (event.type === 'done' && event.files) {
              allFiles = event.files
            }

            if (event.type === 'error') {
              controller.close()
              return
            }
          }

          // Create GitHub repo and commit files
          sendEvent({ type: 'stage', stage: 'committing' })

          const accessToken = decrypt(project.user.githubAccessToken!)
          const octokit = createGitHubClient(accessToken)

          // Create repository
          const repoName = project.name
            .toLowerCase()
            .replace(/[^a-z0-9-]/g, '-')
            .replace(/-+/g, '-')

          const repo = await createRepository(octokit, {
            name: repoName,
            description: project.description || `Generated by True Coding`,
            isPrivate: false,
          })

          // Wait for repo to be ready
          await new Promise((resolve) => setTimeout(resolve, 2000))

          // Commit all files
          await createCommit(
            octokit,
            repo.owner.login,
            repo.name,
            allFiles.map((f) => ({ path: f.path, content: f.content })),
            'Initial commit - Generated by True Coding'
          )

          // Update project with repo URL
          await prisma.project.update({
            where: { id: project.id },
            data: {
              githubRepoUrl: repo.html_url,
              githubRepoOwner: repo.owner.login,
              githubRepoName: repo.name,
              status: 'GENERATING',
            },
          })

          sendEvent({
            type: 'done',
            files: allFiles,
          })

          controller.close()
        } catch (error) {
          sendEvent({
            type: 'error',
            error: error instanceof Error ? error.message : 'Generation failed',
          })
          controller.close()
        }
      },
    })

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        Connection: 'keep-alive',
      },
    })
  } catch (error) {
    console.error('Generate error:', error)
    return new Response(JSON.stringify({ error: 'INTERNAL_ERROR' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    })
  }
}
