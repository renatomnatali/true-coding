import { auth } from '@clerk/nextjs/server'
import { prisma } from '@/lib/db/prisma'
import { generateProject, GenerationEvent } from '@/lib/codegen/generator'
import { TechnicalPlan } from '@/lib/ai/prompts/planning'
import {
  createGitHubClient,
  createRepository,
  createCommit,
  getRepository,
} from '@/lib/github/client'
import { decrypt } from '@/lib/crypto'

export async function POST(request: Request) {
  try {
    const { userId } = await auth()
    if (!userId) {
      return new Response(JSON.stringify({ error: 'UNAUTHORIZED' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json' },
      })
    }

    const body = await request.json()
    const { projectId } = body

    if (!projectId) {
      return new Response(JSON.stringify({ error: 'PROJECT_ID_REQUIRED' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
      })
    }

    // Get project with technical plan
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      include: { user: true },
    })

    if (!project) {
      return new Response(JSON.stringify({ error: 'PROJECT_NOT_FOUND' }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' },
      })
    }

    if (project.user.clerkId !== userId) {
      return new Response(JSON.stringify({ error: 'FORBIDDEN' }), {
        status: 403,
        headers: { 'Content-Type': 'application/json' },
      })
    }

    if (!project.technicalPlan) {
      return new Response(
        JSON.stringify({ error: 'TECHNICAL_PLAN_REQUIRED' }),
        {
          status: 400,
          headers: { 'Content-Type': 'application/json' },
        }
      )
    }

    // Check GitHub connection
    if (!project.user.githubAccessToken) {
      return new Response(
        JSON.stringify({ error: 'GITHUB_NOT_CONNECTED' }),
        {
          status: 400,
          headers: { 'Content-Type': 'application/json' },
        }
      )
    }

    // Create a streaming response
    const encoder = new TextEncoder()
    const stream = new ReadableStream({
      async start(controller) {
        const sendEvent = (event: GenerationEvent) => {
          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify(event)}\n\n`)
          )
        }

        try {
          const technicalPlan = project.technicalPlan as unknown as TechnicalPlan
          const projectData = {
            id: project.id,
            name: project.name,
            description: project.description || '',
            technicalPlan,
            hasAuth: true,
            hasDatabase: !!technicalPlan.database?.prismaSchema,
          }

          let allFiles: Array<{ path: string; content: string }> = []

          // Generate files
          for await (const event of generateProject(projectData)) {
            sendEvent(event)

            if (event.type === 'done' && event.files) {
              allFiles = event.files
            }

            if (event.type === 'error') {
              controller.close()
              return
            }
          }

          // Reuse existing GitHub repo when available, otherwise create one.
          sendEvent({ type: 'stage', stage: 'committing' })

          const accessToken = decrypt(project.user.githubAccessToken!)
          const octokit = createGitHubClient(accessToken)

          let repoUrl = project.githubRepoUrl
          let repoOwner = project.githubRepoOwner
          let repoName = project.githubRepoName
          let defaultBranch = 'main'

          if (!repoOwner || !repoName || !repoUrl) {
            const generatedRepoName = project.name
              .toLowerCase()
              .replace(/[^a-z0-9-]/g, '-')
              .replace(/-+/g, '-')

            const repo = await createRepository(octokit, {
              name: generatedRepoName,
              description: project.description || `Generated by True Coding`,
              isPrivate: true,
            })

            repoUrl = repo.html_url
            repoOwner = repo.owner.login
            repoName = repo.name
            defaultBranch = repo.default_branch || 'main'

            // Wait for repo to be ready
            await new Promise((resolve) => setTimeout(resolve, 2000))
          } else {
            const repo = await getRepository(octokit, repoOwner, repoName)
            defaultBranch = repo.default_branch || 'main'
          }

          if (allFiles.length === 0) {
            throw new Error('NO_FILES_GENERATED')
          }

          // Commit all files
          const commit = await createCommit(
            octokit,
            repoOwner,
            repoName,
            allFiles.map((f) => ({ path: f.path, content: f.content })),
            'Initial commit - Generated by True Coding',
            defaultBranch
          )

          if (!commit?.sha) {
            throw new Error('COMMIT_NOT_CONFIRMED')
          }

          // Update project with repo URL
          await prisma.project.update({
            where: { id: project.id },
            data: {
              githubRepoUrl: repoUrl,
              githubRepoOwner: repoOwner,
              githubRepoName: repoName,
              status: 'GENERATING',
            },
          })

          sendEvent({
            type: 'done',
            files: allFiles,
          })

          controller.close()
        } catch (error) {
          const errorMessage =
            error instanceof Error ? error.message : 'Generation failed'

          // Persist failure so the UI does not keep showing stale "GENERATING" status.
          try {
            await prisma.project.update({
              where: { id: project.id },
              data: { status: 'FAILED' },
            })
          } catch (statusError) {
            console.error('Generate error (status update failed):', statusError)
          }

          sendEvent({
            type: 'error',
            error: errorMessage,
          })
          controller.close()
        }
      },
    })

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        Connection: 'keep-alive',
      },
    })
  } catch (error) {
    console.error('Generate error:', error)
    return new Response(JSON.stringify({ error: 'INTERNAL_ERROR' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    })
  }
}
